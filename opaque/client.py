

# This file was *autogenerated* from the file client.sage
from sage.all_cmdline import *   # import sage library

_sage_const_32 = Integer(32); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
from getpass import getpass
from opaque.common import *
from cryptography.exceptions import InvalidTag


def register(send, recv):

    #pw = b'pwd123'
    pw = getpass("Password:")

    # choose a private and a public key
    p_u = Integer(Fn.random_element())
    P_u = p_u * G

    # choose random r
    r = Integer(Fn.random_element())

    # compute alpha
    alpha = hp(pw) * r

    # send alpha to server
    send(op='register', alpha=alpha)

    # receive beta and P_s from server
    data = recv()
    beta = j2ecp(data, 'beta')
    P_s = j2ecp(data, 'P_s')

    # compute rw and crop it to 256 bits
    rw = h(pw, beta * r.inverse_mod(n))[:_sage_const_32 ]

    # harden rw using a PBKDF (Scrypt)
    rw = pbkdf(rw)

    # encrypt and authenticate p_u, P_u and P_s
    c_data = pickle.dumps((p_u, P_u, P_s))
    c = auth_enc(rw, c_data)

    # send c and P_u to the server
    send(c=c, P_u=P_u)


def login(send, recv):

    #pw = b'pwd123'
    pw = getpass("Password:")

    # choose random r and x_u
    r = Integer(Fn.random_element())
    x_u = Integer(Fn.random_element())

    # compute alpha and X_u
    alpha = hp(pw) * r
    X_u = x_u * G

    # sending alpha and X_u to the server
    send(op='login', alpha=alpha, X_u=X_u)

    # receive beta, X_s, c and A_s
    data = recv()
    beta = j2ecp(data, 'beta')
    X_s = j2ecp(data, 'X_s')
    c = j2b(data['c'])
    A_s = j2b(data['A_s'])

    # check beta belongs to the curve
    if not on_curve(beta):
        return (None, sid, ssid)

    # compute rw and crop it to 256 bits
    rw = h(pw, beta * r.inverse_mod(n))[:_sage_const_32 ]

    # harden rw using a PBKDF (Scrypt)
    rw = pbkdf(rw)

    try:
        # decrypt and authentify c, extract p_u, P_u and P_s
        p_u, P_u, P_s = pickle.loads(auth_dec(rw, c))
    except InvalidTag:
        return (None, sid, ssid)

    # check X_u, P_u, X_s and P_s are all on the curve
    if not on_curve(X_u, P_u, X_s, P_s):
        return (None, sid, ssid)

    # compute ssid', K, SK
    ssidp = h(sid, ssid, alpha)
    K = key_ex_u(p_u, x_u, P_s, X_s, X_u, id_s, id_u, ssidp)
    SK = f(K, _sage_const_0 , ssidp)

    # compute A_s and verify it equals the one received from the server
    if A_s != f(K, _sage_const_1 , ssidp):
        return (None, sid, ssid)

    # compute A_u
    A_u = f(K, _sage_const_2 , ssidp)

    # sending A_u to server
    send(A_u=A_u)

    return (SK, sid, ssid)

